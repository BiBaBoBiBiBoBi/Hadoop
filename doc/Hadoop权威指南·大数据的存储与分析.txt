Mapreduce确保每个reduce的输入都是按键排序的。系统执行排序、将map输出作为输入传给reducer的过程称为shuffle。

map端
map函数开始产生输出时，并不是简单地将它写到磁盘。它利用缓冲的方式写到内存并处于效率的考虑进行预排序。每个map任务都有一个环形内存缓存区用于存储任务输出。
一旦缓冲内容达到阈值，一个后台线程便开始把内容溢出到磁盘。在溢出写到磁盘过程中，map输出继续写到缓冲区，但如果再次期间缓存区被填满，map会被
阻塞知道写磁盘过程完成。
在写磁盘之前，线程首先根据数据最终要传的reducer把数据划分相应的分区。在每个分区中，后台线程按键进行内存中排序，如果有一个combiner函数，
它就在排序后的输出上运行。运行combiner函数使得map输出结果更紧凑，因此减少写到磁盘的数据和传递给reducer的数据。
每次内存缓冲区达到溢出阈值，就会新建一个溢出文件，因此map任务写完其最后一个输出记录之后，会有几个溢出文件。在任务完成之前，溢出文件被合并成
一个已分区且已排序的输出文件。
如果至少存在3个溢出文件时，则combiner就会在输出文件写到磁盘之前再次运行。
reducer通过http协议得到输出文件的分区。

reduce端
map输出文件位于map任务的tasktracker的本地磁盘，现在，tasktracker需要为分区文件运行reduce任务。并且，reduce任务需要集群上若干个map
任务的map输出作为其特殊的分区文件。如果map输出相当小，会被复制到reduce任务JVM的内存，否则，map输出被复制到磁盘。一旦内存缓冲区达到阈值，
则合并后溢出写到磁盘中。如果指定combiner，则在合并期间运行它以降低写入磁盘的数量。
随着磁盘上副本增多，后台线程会将他们合并为更大的、排好序的文件。
复制完所有map输出后，reducer任务进入排序阶段，这个阶段将合并map输出，维持其顺序排序。
在最后阶段，直接把数据输入reduce函数